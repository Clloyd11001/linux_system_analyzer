#!/bin/bash

##### DEFAULT QUESTIONS
#
#       Questions to be answered every run of the program
#
#       Who   – The user who executed the script
        who=${SUDO_USER:-$USER}

#       What  – The functions the user asked to be executed
        # what=

#       When  – At what time/day was the script executed on
        when=$( date '+%Y-%m-%d,%H:%M:%S %Z' )

#       Where – Where on the system was the script called
        # where=$( pwd )

#       Why   - To execute the script
        # why=

##### LOGGER CONSTANTS #####
#
#
#

#Detemines whether a report will be generated
#reportOn=false #Either "true" or "false"

#Name/Path to file where report will be written
reportFile="SystemAnalyzerReport_$( date '+%Y_%m_%d_%H_%M_%S_%Z' )"

#Line to be used to seperate logged info
seperator="------------------------------------------------------------------"

##### LOGGER FUNCTIONS #####
#
#       Functions that help with logging data
#

#Take as input a string and write it to the report file
ltf() {
        if [ ${#1} -eq 0 ]; then
                return
        fi
        echo "$1" >> "$reportFile"
        sync
}

generateLogHeader() {
        if $reportOn; then
                ltf "$seperator"
                ltf "#"
                ltf "#  Report generated on $when"
                ltf "#  Report generated by $who"
                ltf "#  Up since $(uptime --since)"
                ltf "#"
                ltf "$seperator"
        fi
}


##### DATA GATHERING FUNCTIONS #####
#
#       Functions that gather data using command line utilities
#
 
#Determine statistics of the disk obtained from df
field_disk_status=",,"  # Disk Used, Disk Total Size, Percentage Disk Used
function_disk_status() {
        field_disk_status=$( df --human --total | grep total | awk '{ printf "%s,%s,%s",$3,$2,$5 }' )
        if $reportOn; then
                ltf "$seperator"
                ltf "Disk Statistics"
                ltf "Disk Used:                 $(echo "$field_disk_status" | cut -d, -f 1 )"
                ltf "Total Disk Size:   $(echo "$field_disk_status" | cut -d, -f 2 )"
                ltf "% Disk Used:               $(echo "$field_disk_status" | cut -d, -f 3 )"
                ltf "$seperator"
        fi
}

#Determine the date and time of system start
field_uptime_since=""   # YYYY-MM-DD HH:MM:SS
function_uptime_since() {
        field_uptime_since=$( uptime --since )
        if $reportOn; then
                ltf "$seperator"
                ltf "Server Up Since:   $field_uptime_since"
                ltf "$seperator"
        fi
}

#Determine the length of time the system has been up
field_uptime_length=",,"        # # days, # hours, # minutes
function_uptime_length(){
        #Call the uptime command
        local uptime_value
        uptime_value=$( uptime --pretty )
        #       Returns string "# years, # weeks, # days, # hours, # minutes"
        #       string contains only values up to the largest possible segment of time

        #Determine number of years up listed by uptime
        local years_up
        years_up=$( echo "$uptime_value" | grep --only-matching "[0-9]* year[s]\?" | grep --only-matching "[0-9]*" )
        #       If there is no value returned by uptime store a 0
        if [ -z "$years_up" ]; then
                years_up="0"
        fi

        #Determine number of weeks up listed by uptime
        local weeks_up
        weeks_up=$( echo "$uptime_value" | grep --only-matching "[0-9]* week[s]\?" | grep --only-matching "[0-9]*"  )
        #       If there is no value returned by uptime store a 0
        if [ -z "$weeks_up" ]; then
                weeks_up="0"
        fi

        #Determine number of days up listed by uptime
        local days_up
        days_up=$( echo "$uptime_value" | grep --only-matching "[0-9]* day[s]\?" | grep --only-matching "[0-9]*"  )
        #       If there is no value returned by uptime store a 0
        if [ -z "$days_up" ]; then
                days_up="0"
        fi

        #Calculate number of total days up
        days_up=$(( years_up*365 + weeks_up*7 + days_up ))

        #Determine number of hours up from uptime
        local hours_up
        hours_up=$( echo "$uptime_value" | grep --only-matching "[0-9]* hour[s]\?" | grep --only-matching "[0-9]*"  )
        #       If there is no value returned by uptime store a 0
        if [ -z "$hours_up" ]; then
                hours_up="0"
        fi

        #Determine number of minutes up listed by uptime
        local minutes_up
        minutes_up=$( echo "$uptime_value" | grep --only-matching "[0-9]* minute[s]\?" | grep --only-matching "[0-9]*"  )
        #       If there is no value returned by uptime store a 0
        if [ -z "$minutes_up" ]; then
                minutes_up="0"
        fi

        field_uptime_length="$days_up,$hours_up,$minutes_up"

        if $reportOn; then
                ltf "$seperator"
                ltf "Active System Time"
                ltf "Days Up:                   $(echo $field_uptime_length | cut -d, -f 1 )"
                ltf "Hours Up:                  $(echo $field_uptime_length | cut -d, -f 2 )"
                ltf "Minutes Up:                $(echo $field_uptime_length | cut -d, -f 3 )"
                ltf "$seperator"
        fi
}

#Determine the version of the operating system
#   UNUSED   # field_os_version_pretty_name=""  # Value of PRETTY_NAME in /etc/os-release  - Ubuntu 22.10
field_os_version=""     # Combined value of NAME,VERSION of OS - Ubuntu,22.10
                                        #       Obtained from 1. /etc/os-release -> 2. /etc/lsb-release -> 3. NULL
function_os_version() {
        local name
        local version

        if [ -f "/etc/os-release" ]; then
                name=$( grep ^NAME= /etc/os-release | sed -nr 's/.*"(.*)"/\1/p' )
                version=$( grep ^VERSION_ID= /etc/os-release | sed -nr 's/.*"(.*)"/\1/p' )
        elif [ -f "/etc/lsb-release" ]; then
                name=$( sed -nr 's/DISTRIB_ID=(.*)/\1/p' /etc/lsb-release )
                version=$( sed -nr 's/DISTRIB_RELEASE=(.*)/\1/p' /etc/lsb-release )
        else
                name=""
                version=""
        fi

        field_os_version="$name,$version"

        if $reportOn; then
                ltf "$seperator"
                ltf "Operating System"
                ltf "Name:              $(echo $field_os_version | cut -d, -f 1 )"
                ltf "Version:           $(echo $field_os_version | cut -d, -f 2 )"
                ltf "$seperator"
        fi
}

#Determine the hostname of the computer
field_hostname=""
function_hostname() {
        field_hostname=$(hostname)
        if $reportOn; then
                ltf "$seperator"
                ltf "Hostname:          $field_hostname"
                ltf "$seperator"
        fi
}

#Determine the Fully Qualified Domain Name (FQDN) of the host computer
field_fqdn=""
function_hostname_fqdn() {
        field_fqdn=$(hostname --fqdn)
        if $reportOn; then
                ltf "$seperator"
                ltf "Hostname (FQDN):           $field_fqdn"
                ltf "$seperator"
        fi
}

#Determine info related to the kernel 
field_kernel=","        # Kernel Name, Kernel Release Version
function_kernel() {
        field_kernel=$( uname --kernel-name --kernel-release | awk '{ printf "%s,%s", $1, $2 }' )
        if $reportOn; then
                ltf "$seperator"
                ltf "Kernel Name:               $(echo "$field_kernel" | cut -d, -f 1 )"
                ltf "Kernel Version:    $(echo "$field_kernel" | cut -d, -f 2 )"
                ltf "$seperator"
        fi
}

#Determine statistics on memory obtained from free
#  UNUSED  #field_memory=""     # Total Memory, Used Memory,
#              #function_memory() {
#                  #    field_memory=$( free --human --total | grep Total: | awk '{ printf "%s,%s", $2, $3 }' )
#              #}
field_memory=",," # Total Memory, Used Memory, % of Memory Used
function_memory() {
        field_memory=$( free --human --total | grep Total: | awk '{ printf "%s,%s,%.1f%", $2, $3, $3/$2 * 100.0}' )
        if $reportOn; then
                ltf "$seperator"
                ltf "Total Memory:              $(echo "$field_memory" | cut -d, -f 1 )"
                ltf "Memory in Use:     $(echo "$field_memory" | cut -d, -f 2 )"
                ltf "% Memory Used:     $(echo "$field_memory" | cut -d, -f 3 )"
                ltf "$seperator"
        fi
}

#Determine the top processes by memory usage
#       Format: CPU%, Memory%, Process ID, Command/Program
field_top_processes_by_mem=()   #Processes sorted by memory usage
function_top_processes_by_mem() {
        # Obtain the top 5 processes currently running on the system sorted by memory usage
        local top_processes_by_mem
        top_processes_by_mem=$( ps -A --format %cpu,%mem,pid,command --sort=-%mem | tail --lines=+2 | head --lines=5 )

        #List the top 5 programs by memory usage
        while IFS= read -r line ; do
                field_top_processes_by_mem+=( "$( echo "$line" | awk '{printf "%s,%s,%s,%s", $1, $2, $3, $4}')" )
        done <<< "$top_processes_by_mem"


        if $reportOn; then
                ltf "$seperator"
                #Log Processes sorted By Memory Usage
                ltf "Top Processes by Memory Usage"
                ltf "$( echo "CPU%,Memory%,Process ID,Command/Program" | awk 'BEGIN { FS="," }{ printf "    %5.5s %8.8s %12.12s %32.32s", $1, $2, $3, $4 }' )"

                local i
                i=$(( 1 ))
                for process in "${field_top_processes_by_mem[@]}";
                do
                        ltf "$( echo "$process" | awk -v i="$i" 'BEGIN { FS="," }{ printf " %d: %5.5s %8.8s %12.12s %32.32s", i, $1, $2, $3, $4 }' )"
                        i=$(( i + 1 ))
                done
                ltf "$seperator"
        fi
}

#Determine the top processes by CPU usage
#       Format: CPU%, Memory%, Process ID, Command/Program
field_top_processes_by_cpu=()   #Processes sorted by CPU usage
function_top_processes_by_cpu() {

        # Obtain the top 5 processes currently running on the system sorted by cpu usage
        local top_processes_by_cpu
        top_processes_by_cpu=$( ps -A --format %cpu,%mem,pid,command --sort=-%cpu | tail --lines=+2 | head --lines=5 )

        #List the top 5 programs by CPU usage
        while IFS= read -r line ; do
                field_top_processes_by_cpu+=( "$( echo "$line" | awk '{printf "%s,%s,%s,%s", $1, $2, $3, $4}')" )
        done <<< "$top_processes_by_cpu"

        if $reportOn; then
                ltf "$seperator"
                #Log Processes sorted By CPU Usage
                ltf "Top Processes by CPU Usage"
                ltf "$( echo "CPU%,Memory%,Process ID,Command/Program" | awk 'BEGIN { FS="," }{ printf "    %5.5s %8.8s %12.12s %32.32s", $1, $2, $3, $4 }' )"

                local i
                i=$(( 1 ))
                for process in "${field_top_processes_by_cpu[@]}";
                do
                        ltf "$( echo "$process" | awk -v i="$i" 'BEGIN { FS="," }{ printf " %d: %5.5s %8.8s %12.12s %32.32s", i, $1, $2, $3, $4 }' )"
                        i=$(( i + 1 ))
                done
                ltf "$seperator"
        fi
}

#Obtain the current shell in use by the user
field_shell="" 
function_shell() {
        field_shell="$SHELL" #Obtain the current shell from the environment variable $SHELL
        if $reportOn; then
                ltf "$seperator"
                ltf "User's Shell:              $field_shell"
                ltf "$seperator"
        fi
}

#Determine information about the CPU from lscpu
field_cpu=",,,,"        # Number of CPU Cores, Vendor, Model Name, Core Clock, Architecture
function_cpu() {
        ls_cpu_response=$(lscpu)
        cpu_cores=$( echo "$ls_cpu_response" | sed -nr 's/^CPU\(s\):[ \t]*([0-9]*)/\1/p'  )
        architecture=$( echo "$ls_cpu_response" | sed -nr 's/^Architecture:[ \t]*(.*)/\1/p'  )
        model_name=$( echo "$ls_cpu_response" | sed -nr 's/^Model name:[ \t]*(.*)/\1/p'  | awk 'BEGIN { FS="@" } { print $1 }' )
        vendor=$( echo "$ls_cpu_response" | sed -nr 's/^Vendor ID:[ \t]*(.*)/\1/p'  )
        clock_speed=$( echo "$ls_cpu_response" | grep @ | grep -o "[0-9]*.[0-9]*[A-Z]Hz" )
        field_cpu="$cpu_cores,$architecture,$model_name,$vendor,$clock_speed"
}
field_motherboard=",,," # Manufacturer, Serial Number, Asset Tag
field_bios=",,,"
function_motherboard(){
        manufacturer=$( dmidecode -t baseboard | grep 'Manufacturer:'  | sed 's/^.*: //')
        serial_number=$(dmidecode -t baseboard | grep 'Serial Number:' | sed 's/^.*: //')
        asset_number=$(dmidecode -t baseboard | grep 'Asset Tag:' | sed 's/^.*: //')
        vendor=$( dmidecode -s bios-vendor)
        version=$(dmidecode -s bios-version)
        release_date=$(dmidecode -s bios-release-date)

        field_motherboard="$manufacturer, $serial_number, $asset_number, $release_date"
}
field_gpu=",,"
function_gpu(){
        vendor=$(lshw -C display | grep "vendor:" | sed 's/^.*: //')
        description=$(lshw -C display | grep 'description: ' | sed 's/^.*: //')
        field_gpu="$vendor, $description"
}
#Determine the current resolution 
field_resolution="" # Pixel WidthXPixel Height
function_resolution() {
        field_resolution=$( xrandr --query | sed -nr 's/.*current ([0-9]+) x ([0-9]+).*/\1X\2/p' )
        if $reportOn; then
                ltf "$seperator"
                ltf "Resolution:                $field_resolution"
                ltf "$seperator"
        fi
}

#Obtain information related to root and standard users 
field_users=()  # Info on Users with UID>=1000 and UID=0 | Username,User ID,Group ID,Home Directory,Shell/Command
function_users() {
        #Layout of /etc/passwd
        #       Username:Password Info:User ID(UID):Group ID(GID):User ID Info(GECOS):Home Directory:Shell/Command
        #               $1 = Username
        #               $2 = Password Info
        #               $3 = User ID
        #               $4 = Group ID
        #               $5 = User ID Info(GECOS)
        #               $6 = Home Directory
        #               $7 = Shell/Command

        #Store users with UID above 1000 and = 0
        users=$( getent passwd 0 & getent passwd {1000..60000} )
        if $reportOn; then
                ltf "$seperator"
                ltf "The following is a list of users and related info"
                ltf " "
        fi
        while IFS= read -r line ; do
                local user
                user=$( echo "$line" | awk 'BEGIN { FS=":" } { printf "%s",$1 }' )

                local user_info
                user_info=$( echo "$line" | awk 'BEGIN { FS=":" } { printf "%s,%s,%s,%s,%s",$1,$3,$4,$6,$7 }' )

                local last_login
                last_login=$( last --time-format iso --limit 1 "$user" | sed -nr 's/^'"$user"'.*([0-9]{4}-[0-9]{2}-[0-9]{2}[A-Z]*[0-9]{2}:[0-9]{2}:[0-9]{2}\+[0-9]{2}:[0-9]{2}).*/\1/p'  )

                if [ -z "$last_login" ]; then
                        last_login="0000-00-00T00:00:00+00:00"
                fi

                local groups
                groups=$( groups "$user" | cut -d: -f 2 | sed 's/ //')

                field_users+=( "$user_info,$last_login,${groups// /|}"  )
                if $reportOn; then
                        ltf " "
                        ltf "Username:                  $(echo "$user_info" | cut -d, -f 1 )"
                        ltf "User ID:                   $(echo "$user_info" | cut -d, -f 2 )"
                        ltf "Group ID:                  $(echo "$user_info" | cut -d, -f 3 )"
                        ltf "Home Directory:    $(echo "$user_info" | cut -d, -f 4 )"
                        ltf "SHELL:                     $(echo "$user_info" | cut -d, -f 5 )"
                        ltf "Previous Login:    $last_login"
                        ltf "Groups:                    $groups"
                        ltf " "
                fi
        done <<< "$users"
        if $reportOn; then
                ltf "$seperator"
        fi
}
######################
#                                        
#     UNFINISHED     
#
# Purpose - gather number
#       of packages installed on
#       the system for different
#       package managers
#
# field_dpkg_count=""
# field_snap_count=""
# package_counter() {
        # #dpkg
        # field_dpkg_count=$( dpkg --list | grep --count "^ii" )
        # #snap
        # field_snap_count=$( snap list | tail --lines=+2 | wc --lines )
        # #pacman

        # #rpm

        # #yum

# }

field_interfaces=()
function_network(){
        # Format: Interface Name i.e. lo, eth0, enp0s3, ens3
        local interfaces=()
        while IFS= read -r interface ; do
                interfaces+=( "$interface" )
        done <<< "$( ip link show | sed -nr 's/^[0-9]+: (.*):.*/\1/p' )"

        for interface in "${interfaces[@]}"
        do
                local interface_info
                interface_info=$( ip addr show "$interface" )

                # MAC Address,Broadcast Address
                local mac_address
                mac_address=$( echo "$interface_info" | sed -nr 's/    link\/(ether|loopback) (.*) brd (.*)/\2,\3/p' )

                # IPv4 Address,Broadcast Address
                local ipv4_addresses=()
                while IFS= read -r ipv4_address ; do
                        ipv4_addresses+=( "$ipv4_address" )
                done <<< "$( echo "$interface_info" | sed -nr 's/    inet ([0-9./]*) (brd ([0-9.]*) )?.*/\1,\3/p' )"

                # IPv6 Address
                local ipv6_addresses=()
                while IFS= read -r ipv6_address ; do
                        ipv6_addresses+=( "$ipv6_address" )
                done <<< "$( echo "$interface_info" | sed -nr 's/    inet6 ([a-f0-9:/]*).*/\1/p' )"

                if $reportOn; then
                        ltf "$seperator"
                        ltf "Interface:         $interface"
                        ltf " "
                        ltf "$( echo MAC Address,Broadcast | awk 'BEGIN { FS="," }{ printf "%25.25s %25.25s", $1, $2 }' )"
                        ltf "$( echo "$mac_address" | awk 'BEGIN { FS="," }{ printf "%25.25s %25.25s", $1, $2 }' )"
                        ltf " "
                        ltf "$( echo IPv4 Address,Broadcast | awk 'BEGIN { FS="," }{ printf "%25.25s %25.25s", $1, $2 }' )"
                        for ipv4_address in "${ipv4_addresses[@]}";
                        do
                                ltf "$( echo "$ipv4_address" | awk 'BEGIN { FS="," }{ printf "%25.25s %25.25s", $1, $2 }' )"
                        done
                        ltf " "
                        ltf "$( echo "IPv6 Address" | awk 'BEGIN { FS="," }{ printf "%25.25s", $1 }' )"
                        for ipv6_address in "${ipv6_addresses[@]}";
                        do
                                ltf "$( echo "$ipv6_address" | awk 'BEGIN { FS="," }{ printf "%51.51s", $1 }' )"
                        done
                        ltf "$seperator"
                fi

                local interface_line
                interface_line="$interface,${mac_address//,/!/},"

                for (( index=0; index<${#ipv4_addresses[@]}; index++ ))
                do
                        if [[ $(( index + 1 )) < ${#ipv4_addresses[@]} ]]; then
                                interface_line="$interface_line${ipv4_addresses[index]//,/!}|"
                        else
                                interface_line="$interface_line${ipv4_addresses[index]//,/!}"
                        fi
                done

                interface_line="$interface_line,"

                for (( index=0; index<${#ipv6_addresses[@]}; index++ ))
                do
                        if [[ $(( index + 1 )) < ${#ipv6_addresses[@]} ]]; then
                                interface_line="$interface_line${ipv6_addresses[index]}|"
                        else
                                interface_line="$interface_line${ipv6_addresses[index]}"
                        fi
                done
                field_interfaces+=( "$interface_line" )
        done
}

#####################################################################
#                                      ___   ___           
#            /|    //| |     // | |       / /    /|    / / 
#           //|   // | |    //__| |      / /    //|   / /  
#          // |  //  | |   / ___  |     / /    // |  / /   
#         //  | //   | |  //    | |    / /    //  | / /    
#        //   |//    | | //     | | __/ /___ //   |/ /     
#
#       ALL CODE BEYOND THIS POINT IS EXECUTED UPON CALLING THE SCRIPT
#
#####################################################################

#
# Process of Execution
#
# Determine the commands to execute and store a representative value in an array
# For each value call its corresponding function and mark the file to be create
# Using the fields generated when calling functions write the CSV files
#

##### INPUT PARSING #####
#
#       Parse options and determine which functions to call
#

#An Array storing a list of files to create/write to
        files=()


#An Array storing a list of the commands selected
        add_command() {
                if [ "${commands[0]}" != "all" ]; then
                        commands+=( "$1" )
                fi
        }
        commands=()

#Toggles (flags) for the type of files to write
        reportOn=false
        csvOn=true

# Loop over arguments given when the script was called
while [ $# -gt 0 ]
do
        case "$1" in
                --csv )
                        toggle="$2"
                        if [ "$toggle" == "on" ]; then
                                csvOn=true
                                shift
                        elif [ "$toggle" == "off" ]; then
                                csvOn=false
                                shift
                        else
                                case "$toggle" in
                                        --* | -* | "" )
                                                csvOn=true
                                        ;;
                                        *)
                                                echo "The option --report must be followed \"on\", \"off\", or nothing not $toggle"
                                                exit 1
                                        ;;
                                esac
                        fi
                ;;
                --report )
                        toggle="$2"
                        if [ "$toggle" == "on" ]; then
                                reportOn=true
                                shift
                        elif [ "$toggle" == "off" ]; then
                                reportOn=false
                                shift
                        else
                                case "$toggle" in
                                        --* | -* | "" )
                                                reportOn=true
                                        ;;
                                        *)
                                                echo "The argument --report must be followed \"on\", \"off\", or nothing not $toggle"
                                                exit 1
                                        ;;
                                esac
                        fi
                ;;
                --all | -a )
                        commands=()
                        add_command "all"
                ;;
                --resolution | -r )
                        add_command "resolution"
                ;;
                --cpu )
                        add_command "cpu"
                ;;
                --gpu )
                        add_command "gpu"
                ;;
                --motherboard )
                        add_command "motherboard"
                ;;
                --disk | -d )
                        add_command "disk"
                ;;
                --processes | -p )
                        option="$2"
                        if [ "$option" == "cpu" ]; then
                                add_command "processes_cpu"
                                shift
                        elif [ "$option" == "mem" ]; then
                                add_command "processes_mem"
                                shift
                        else
                                case "$option" in
                                        --* | -* | "" )
                                                add_command "processes_cpu"
                                        ;;
                                        *)
                                                echo "The argument --processes must be followed \"cpu\", \"mem\", or nothing not $option"
                                                exit 1
                                        ;;
                                esac
                        fi
                ;;
                --kernel | -k )
                        add_command "kernel"
                ;;
                --memory | -m )
                        add_command "memory"
                ;;
                --network | -n )
                        add_command "network"
                ;;
                --users | -u )
                        add_command "users"
                ;;
                --shell | -s )
                        add_command "shell"
                ;;
                --hostname )
                        add_command "hostname"
                ;;
                --fqdn )
                        add_command "fqdn"
                ;;
                --uptime | --up )
                        add_command "uptime"
                ;;
                --os )
                        add_command "os"
                ;;
                --help | -h )
                        #Write Help Message
                ;;
                * )
                        echo "Error: argument $1 undefined for this script"
                        exit
                ;;
        esac
        shift
done

##### COMMAND CALLING #####
#
#       Calling the requested functions


#Iterate over the commands stored in the array 
#       and call their respective functions as well
#       as marking the CSV file to be created
for command in "${commands[@]}"
do
        case $command in
                all )
                        files+=( "Hardware" )
                        files+=( "System_Info" )
                        files+=( "Network" )
                        files+=( "Users" )
                        function_cpu
                        function_motherboard
                        function_disk_status
                        function_hostname
                        function_hostname_fqdn
                        function_kernel
                        function_memory
                        function_gpu
                        function_network
                        function_os_version
                        function_resolution
                        function_shell
                        function_top_processes_by_cpu
                        function_top_processes_by_mem
                        function_uptime_length
                        function_users
                ;;
                cpu )
                        files+=( "Hardware" )
                        function_cpu
                ;;
                motherboard )
                       files+=("Hardware")
                       function_motherboard
                ;;
                gpu )
                       files+=("Hardware")
                       function_gpu
                ;;
                disk )
                        files+=( "Hardware" )
                        function_disk_status
                ;;
                hostname )
                        files+=( "System_Info" )
                        function_hostname
                ;;
                fqdn )
                        files+=( "System_Info" )
                        function_hostname_fqdn
                ;;
                kernel )
                        files+=( "System_Info" )
                        function_kernel
                ;;
                memory)
                        files+=( "Hardware" )
                        function_memory
                ;;
                network )
                        files+=( "Network" )
                        function_network
                ;;
                os )
                        files+=( "System_Info" )
                        function_os_version
                ;;
                resolution)
                        files+=( "System_Info" )
                        function_resolution
                ;;
                shell )
                        files+=( "System_Info" )
                        function_shell
                ;;
                processes_cpu )
                        files+=( "Top_Processes_By_CPU_Usage" )
                        function_top_processes_by_cpu
                ;;
                processes_mem )
                        files+=( "Top_Processes_By_Memory_Usage" )
                        function_top_processes_by_mem
                ;;
                uptime)
                        files+=( "System_Info" )
                        function_uptime_length
                ;;
                users )
                        files+=( "Users" )
                        function_users
                ;;
        esac
done

##### FILE WRITING #####
#
# Write requested data to appropriate files
#

if $reportOn; then
        #Generate Log Header if report file is empty
        [ -s "$reportFile" ] || generateLogHeader
fi

#Build Default line entry
entry_begin="$who,$when"

if $csvOn; then
        #Write CSV Files
        for file in "${files[@]}"
        do
                case $file in
                        Users )
                                #If the file does not exist
                                if [[ ! -f "$file.csv" ]]; then
                                        #Write header to empty file
                                        echo "Executioner,Date,Time,Username,User ID,Group ID,Home Directory,Shell/Command,Last Login Time,Groups" > "$file.csv"
                                fi
                                for user in "${field_users[@]}"
                                do
                                        # Append entry to file
                                        echo "$entry_begin,$user" >> "$file.csv"
                                done
                        ;;
                        Hardware )
                                #If the file does not exist
                                if [[ ! -f "$file.csv" ]]; then
                                        #Write header to empty file
                                        echo "Executioner,Date,CPU Cores, Architecture, Model Name, Vendor, Clock Speed, Manufacturer, Serial Number, Asset Number, Vendor, Release Date, GPU Driver" > "$file.csv"

                                fi
                                # Append entry to file
                                echo "$entry_begin,""$field_cpu,""$field_motherboard,""$field_memory,""$field_gpu" >> "$file.csv"
                        ;;
                        Network)
                                if [[ ! -f "$file.csv" ]]; then
                                        #Write header to empty file
                                        echo "Executioner,Date,Time,Interface,MAC Address(link/ether!brd),IPv4 Address(IP!brd),IPv6 Address" > "$file.csv"
                                fi
                                for interface in "${field_interfaces[@]}"
                                do
                                        # Append entry to file
                                        echo "$entry_begin,$interface" >> "$file.csv"
                                done
                        ;;
                        System_Info )
                                #If the file does not exist
                                if [[ ! -f "$file.csv" ]]; then
                                        #Write header to empty file
                                        echo "Executioner,Date,Time,Hostname,Fully Qualified Domain Name,OS Name,OS Version,Kernel Name, Kernel Release Version,Resolution,# Days up,# Minutes up,# Seconds up" > "$file.csv"
                                fi
                                # Append entry to file
                                echo "$entry_begin,$field_hostname,$field_fqdn,$field_os_version,$field_kernel,$field_resolution,$field_uptime_length" >> "$file.csv"
                        ;;
                        Top_Processes_By_CPU_Usage )
                                if [[ ! -f "$file.csv" ]]; then
                                        #Write header to empty file
                                        echo "Executioner,Date,Time,CPU%,Memory%,Process ID,Command/Program" > "$file.csv"
                                fi
                                for process in "${field_top_processes_by_cpu[@]}"
                                do
                                        # Append entry to file
                                        echo "$entry_begin,$process" >> "$file.csv"
                                done
                        ;;
                        Top_Processes_By_Memory_Usage )
                                if [[ ! -f "$file.csv" ]]; then
                                        #Write header to empty file
                                        echo "Executioner,Date,Time,CPU%,Memory%,Process ID,Command/Program" > "$file.csv"
                                fi
                                for process in "${field_top_processes_by_mem[@]}"
                                do
                                        # Append entry to file
                                        echo "$entry_begin,$process" >> "$file.csv"
                                done
                        ;;
                esac
        done
fi